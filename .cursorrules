# SaaS Starter Kit - Cursor Rules

## Architecture Overview
This is a production-ready SaaS starter kit with Next.js, Supabase, and Drizzle ORM.
Always follow these patterns to maintain consistency across the codebase.

## Tech Stack
- **Framework**: Next.js 14+ (App Router)
- **Database**: Supabase (PostgreSQL)
- **ORM**: Drizzle ORM (type-safe database operations)
- **Auth**: Supabase Auth (Magic Links, OAuth)
- **Styling**: Tailwind CSS
- **Deployment**: Vercel
- **Language**: TypeScript (strict mode)

## Project Structure
```
/app              - Next.js app router (pages, layouts, API routes)
/components       - Reusable React components
/lib/db          - Drizzle schema, migrations, database utilities
/lib/supabase    - Supabase client configuration (server & client)
/drizzle         - Generated database migrations
/public          - Static assets
```

## Core Principles
1. **Server Components by Default**: Use React Server Components unless you need interactivity
2. **Type Safety**: Always use TypeScript with proper types
3. **Security First**: Never expose service role keys, validate all inputs
4. **Clean Code**: Small, focused functions and components
5. **Database First**: Define schema before building features

## Database Patterns with Drizzle

### Schema Definition
All schemas go in `/lib/db/schema.ts`. Use proper relationships and constraints.

Example:
```typescript
import { pgTable, text, timestamp, uuid, boolean } from 'drizzle-orm/pg-core'

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: text('email').notNull().unique(),
  fullName: text('full_name'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})
```

### Migration Workflow
1. Update schema in `/lib/db/schema.ts`
2. Generate migration: `npm run db:generate`
3. Review migration in `/drizzle`
4. Apply migration: `npm run db:migrate`

### Database Operations
Always use Drizzle for queries:
```typescript
import { db } from '@/lib/db'
import { users } from '@/lib/db/schema'
import { eq } from 'drizzle-orm'

// Insert
await db.insert(users).values({ email: 'user@example.com' })

// Select
await db.select().from(users).where(eq(users.email, 'user@example.com'))

// Update
await db.update(users).set({ fullName: 'John Doe' }).where(eq(users.id, userId))

// Delete
await db.delete(users).where(eq(users.id, userId))
```

## Authentication Patterns

### Server-Side Auth (Server Components, API Routes)
```typescript
import { createClient } from '@/lib/supabase/server'

const supabase = createClient()
const { data: { user }, error } = await supabase.auth.getUser()

if (!user) {
  redirect('/login')
}
```

### Client-Side Auth (Client Components)
```typescript
'use client'

import { createClient } from '@/lib/supabase/client'
import { useEffect, useState } from 'react'

const supabase = createClient()
const [user, setUser] = useState(null)

useEffect(() => {
  supabase.auth.getUser().then(({ data }) => setUser(data.user))
}, [])
```

### Protected Routes
Create middleware or check auth in layout.tsx:
```typescript
// app/dashboard/layout.tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export default async function DashboardLayout({ children }) {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    redirect('/login')
  }
  
  return <>{children}</>
}
```

## API Route Patterns

All API routes go in `/app/api/*/route.ts`

### Standard API Route Structure
```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { db } from '@/lib/db'
import { z } from 'zod'

// Input validation schema
const schema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
})

export async function POST(request: Request) {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // 2. Parse and validate input
    const body = await request.json()
    const validatedData = schema.parse(body)

    // 3. Database operation
    const result = await db.insert(yourTable).values({
      ...validatedData,
      userId: user.id,
    }).returning()

    // 4. Return success response
    return NextResponse.json({ data: result[0] }, { status: 201 })

  } catch (error) {
    // 5. Handle errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid input', details: error.errors },
        { status: 400 }
      )
    }

    console.error('API Error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

### HTTP Status Codes
- 200: Success (GET, PUT, DELETE)
- 201: Created (POST)
- 400: Bad Request (validation errors)
- 401: Unauthorized (not logged in)
- 403: Forbidden (logged in but no permission)
- 404: Not Found
- 500: Internal Server Error

## Component Patterns

### When to Use "use client"
Only use "use client" directive when you need:
- React hooks (useState, useEffect, etc.)
- Event handlers (onClick, onChange, etc.)
- Browser APIs (localStorage, window, etc.)
- Third-party libraries that need browser context

Default to Server Components for better performance.

### Component Organization
```typescript
// components/ui/Button.tsx
'use client'

import { ButtonHTMLAttributes } from 'react'

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary'
  isLoading?: boolean
}

export function Button({ 
  variant = 'primary', 
  isLoading, 
  children, 
  ...props 
}: ButtonProps) {
  return (
    <button
      className={`btn btn-${variant}`}
      disabled={isLoading}
      {...props}
    >
      {isLoading ? 'Loading...' : children}
    </button>
  )
}
```

## Environment Variables

### Required Variables (.env.local)
```
# Supabase
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key

# Database (from Supabase)
DATABASE_URL=postgresql://postgres:[password]@db.[project-ref].supabase.co:5432/postgres

# App
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

### Variable Usage Rules
- `NEXT_PUBLIC_*` - Exposed to browser, use for public data only
- Other variables - Server-side only, never expose to client

## Code Style Guidelines

### TypeScript
- Use strict mode
- Define interfaces for all props and data structures
- Avoid `any` type
- Use proper return types for functions

### Naming Conventions
- Components: PascalCase (`UserProfile.tsx`)
- Files: kebab-case or PascalCase (`user-profile.ts` or `UserProfile.ts`)
- Functions: camelCase (`getUserData`)
- Constants: UPPER_SNAKE_CASE (`API_BASE_URL`)

### Imports
```typescript
// External packages first
import { useState } from 'react'
import { z } from 'zod'

// Internal imports with @/ alias
import { db } from '@/lib/db'
import { Button } from '@/components/ui/Button'
```

## Common Development Tasks

### Adding a New Feature
1. **Plan the database schema** - What tables/columns needed?
2. **Update schema.ts** - Add new tables or modify existing
3. **Generate migration** - `npm run db:generate`
4. **Review migration** - Check SQL in `/drizzle` folder
5. **Apply migration** - `npm run db:migrate`
6. **Create API routes** - Build backend logic
7. **Build UI components** - Create frontend
8. **Test end-to-end** - Verify everything works

### Adding Authentication to a Page
```typescript
// Option 1: Layout-level protection
// app/protected/layout.tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export default async function Layout({ children }) {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) redirect('/login')
  return <>{children}</>
}

// Option 2: Page-level protection
// app/protected/page.tsx
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export default async function Page() {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) redirect('/login')
  
  return <div>Protected content</div>
}
```

### Creating a New API Endpoint
1. Create file: `/app/api/your-endpoint/route.ts`
2. Implement HTTP methods: GET, POST, PUT, DELETE
3. Add auth check, validation, database logic
4. Return proper status codes and JSON responses

## Error Handling Best Practices

### API Routes
```typescript
try {
  // Operation
} catch (error) {
  // Log for debugging
  console.error('Operation failed:', error)
  
  // Return user-friendly error
  return NextResponse.json(
    { error: 'Something went wrong' },
    { status: 500 }
  )
}
```

### Client Components
```typescript
'use client'

import { useState } from 'react'

export function MyForm() {
  const [error, setError] = useState<string | null>(null)
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)
    
    try {
      const res = await fetch('/api/endpoint', { method: 'POST' })
      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error || 'Request failed')
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Something went wrong')
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="error">{error}</div>}
      {/* form fields */}
    </form>
  )
}
```

## Performance Optimization

1. **Use Server Components** - Fetch data on server, reduce client JS
2. **Streaming with Suspense** - Show loading states progressively
3. **Image Optimization** - Use Next.js `<Image>` component
4. **Font Optimization** - Use `next/font` for web fonts
5. **Database Indexes** - Add indexes to frequently queried columns

## Security Checklist

- [ ] Never expose `SUPABASE_SERVICE_ROLE_KEY` to client
- [ ] Validate all user inputs with Zod
- [ ] Use Row Level Security (RLS) in Supabase
- [ ] Sanitize user-generated content
- [ ] Use HTTPS in production
- [ ] Set proper CORS headers
- [ ] Rate limit API endpoints
- [ ] Never trust client-side data

## Testing Strategy

1. **Manual Testing** - Test user flows in browser
2. **Database Testing** - Verify migrations and queries
3. **API Testing** - Test endpoints with Postman/Thunder Client
4. **Auth Testing** - Test login, signup, logout flows

## Deployment Checklist

- [ ] All environment variables set in Vercel
- [ ] Database migrations applied
- [ ] Supabase RLS policies configured
- [ ] Custom domain configured (if needed)
- [ ] Error tracking setup (Sentry, etc.)
- [ ] Analytics setup (if needed)

## When You Ask Claude for Help

Be specific about what you need:
- "Add a posts table with user relationship and timestamps"
- "Create an API route to update user profile"
- "Build a login form with Supabase auth"
- "Add pagination to the posts list"

Claude will follow these rules and generate code that fits perfectly into this architecture.
